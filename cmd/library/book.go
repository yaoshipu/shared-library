package main

import (
	"errors"
	"fmt"
	"time"

	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

// Book struct
type Book struct {
	// ID is auto generated by mgo, ready only
	ID         bson.ObjectId `bson:"_id"                json:"id"`
	Author     string        `bson:"author"             json:"author"`
	Name       string        `bson:"name"               json:"name"`
	Donator    string        `bson:"donator"            json:"donator"`
	UpdateTime int64         `bson:"update_time"        json:"update_time"`
	Owner      string        `bson:"book_owner"         json:"book_owner"`
	Image      string        `bson:"image_url"          json:"image_url"`
}

// MyBooks struct
type MyBooks struct {
	Borrowed []*Book `bson:"borrowed"             json:"borrowed"`
	Donated  []*Book `bson:"donated"              json:"donated"`
}

// BookColl struct
type BookColl struct {
	coll *mgo.Collection
}

// NewBookColl constructor
func NewBookColl(cfg *MgoConfig) (*BookColl, error) {
	session := Open(cfg)

	err := session.Coll.EnsureIndex(mgo.Index{Key: []string{"name", "donator"}, Unique: true})
	if err != nil {
		return nil, fmt.Errorf("EnsureIndex error: %v", err)
	}

	return &BookColl{coll: session.Coll}, nil
}

// Create ...
func (c *BookColl) Create(book *Book) error {
	coll := FastCopyCollection(c.coll)
	defer CloseCollection(coll)

	if book == nil {
		return errors.New("nil Favorite args")
	}

	book.ID = bson.NewObjectId()
	book.UpdateTime = time.Now().Unix()

	return coll.Insert(book)
}

// ListOption ...
type ListOption struct {
	Name    string
	Author  string
	Owner   string
	Donator string
}

// List ...
func (c *BookColl) List(opt *ListOption) ([]*Book, error) {
	coll := FastCopyCollection(c.coll)
	defer CloseCollection(coll)

	if opt == nil {
		return nil, errors.New("nil ListOption")
	}

	query := bson.M{}

	if len(opt.Name) != 0 {
		query["name"] = opt.Name
	}

	if len(opt.Author) != 0 {
		query["author"] = opt.Author
	}

	if len(opt.Owner) != 0 {
		query["owner"] = opt.Owner
	}

	if len(opt.Donator) != 0 {
		query["donator"] = opt.Donator
	}

	var resp []*Book
	err := coll.Find(query).All(&resp)
	return resp, err
}
